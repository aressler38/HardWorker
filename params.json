{"name":"Hardworker","tagline":"","body":"\r\n# HardWorker #\r\nAn instance of HardWorker creates a new Worker and gives you an API to execute \r\ncallbacks and load modules inside of the Worker's context. These features allow you\r\nto manage multiple tasks  \r\nThink of it as your Web Worker liaison.\r\n\r\n# API #\r\n\r\nFirst, make a new `HardWorker` instance.\r\n\r\n    var hardWorker = new HardWorker();\r\n\r\n#### loadScript\r\n\r\nUse `loadScript` when you need to import a library file. For example:\r\n\r\n    hardWorker.loadScript( \"./lib/require.js\" , callback );\r\n\r\nThe first parameter is a url path to the JavaScript file that you want. The second parameer is optional, but\r\nit's triggered when the `onload` of the `XMLHttpRequest` *inside* the worker executes. It's executed in the \r\ncontext of the window (not the worker). A call to `loadScript` is similar to a call to `loadModule` except that\r\nno `workerCallback` function are bound.\r\n\r\n#### loadModule\r\n\r\nUse `loadModule` to GET a JavaScript IIFE or AMD file. In either case, the module needs to return a function.\r\n\r\n    hardWorker.loadModule({\r\n        trigger: \"foo\", \r\n        path: \"./some_url_path/myModule.js\"\r\n    }, workerCallback, XHRCallback);\r\n\r\nThe `loadModule` method takes three arguments: (1) an object representing where the physical file resides and \r\nan alias (trigger) that allows you to execute the module, (2) the `workerCallback` that is executed after you \r\ntrigger the module, and (3) the `XHRCallback`, which becomes the onload of an XMLHttpRequest, and is called after \r\nthe module finishes transfering into the browser. \r\n\r\n*Example Modules*\r\n\r\nA module file can be a self calling function:\r\n    \r\n    (function (global) {\r\n        return function identityTask(trigger_data) {\r\n            return trigger_data;\r\n        }\r\n    })(this);\r\n\r\nIf you've already loaded an AMD loader via `loadModule`, then you can start loading AMD files:\r\n\r\n    define([\"dependency\"], function(baz) {\r\n        return task(data) {\r\n            return baz(data);\r\n        };\r\n    }); \r\n\r\n#### trigger\r\n\r\nTrigger a worker module and pass data to your task function. \r\n\r\n    hardWorker.trigger( \"foo\" , { bar: \"baz\" } ); \r\n\r\nThis example will signal `HardWorker` to find the module associated with the \"foo\" trigger and execute it by\r\npassing any additional parameters (e.g. `{bar:\"baz\"}`).\r\n\r\n\r\n#### on\r\n\r\nBind additional event handlers to a given trigger. \r\n\r\n    hardWorker.on( \"foo\", function(data_from_module_return_value) {\r\n        // You needed to bind another worker callback for whatever reason. \r\n    });\r\n\r\n\r\n## TODOs \r\n* test cases for requirejs support. \r\n* allow loading scripts like worker.loadScript, however don't use loadScript because it gives no callback support.\r\n* combine scriptLoaderHandler and moduleReadyHandler into a pending[whatever] handler\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}